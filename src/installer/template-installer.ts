import { copyFileSync, existsSync, mkdirSync, readFileSync, writeFileSync, readdirSync } from 'fs';
import { join, dirname } from 'path';
import ora from 'ora';
import chalk from 'chalk';
import yaml from 'yaml';

/**
 * Template Installer
 *
 * Copies template files from src/templates/ to project .roo/ directory.
 * Handles:
 * - .roo/rules/ (custom instructions)
 * - .roo/rules-roo-commander/ (mode-specific rules)
 * - .roo/commands/ (slash commands)
 * - .roomodes (mode configuration, merged with existing)
 */

export interface InstallOptions {
  /** Project root directory */
  projectRoot: string;
  /** Template source directory (defaults to package src/templates) */
  templatesDir?: string;
  /** Force reinstall (overwrite existing files) */
  force?: boolean;
}

export interface InstallResult {
  success: boolean;
  filesInstalled: string[];
  errors: string[];
}

/**
 * Install all Roo Commander templates to project
 *
 * @param options Install options
 * @returns Install result with list of files installed
 */
export async function installTemplates(
  options: InstallOptions
): Promise<InstallResult> {
  const { projectRoot, templatesDir, force = false } = options;

  const filesInstalled: string[] = [];
  const errors: string[] = [];

  // Determine templates directory
  const templates = templatesDir || getTemplatesDir();

  if (!existsSync(templates)) {
    return {
      success: false,
      filesInstalled: [],
      errors: [`Templates directory not found: ${templates}`],
    };
  }

  // Check if already installed
  const rooCommanderDir = join(projectRoot, '.roo', 'rules-roo-commander');
  if (existsSync(rooCommanderDir) && !force) {
    console.log(
      chalk.yellow(
        `\n⚠️  Roo Commander already installed at ${chalk.cyan(rooCommanderDir)}`
      )
    );
    console.log(
      chalk.gray(
        `Run with --force to reinstall, or remove .roo/rules-roo-commander/ first.\n`
      )
    );
    return {
      success: false,
      filesInstalled: [],
      errors: ['Already installed (use --force to reinstall)'],
    };
  }

  const spinner = ora('Installing Roo Commander templates...').start();

  try {
    // 1. Create .roo/ directory structure
    const rooDirs = [
      join(projectRoot, '.roo'),
      join(projectRoot, '.roo', 'rules'),
      join(projectRoot, '.roo', 'rules-roo-commander'),
      join(projectRoot, '.roo', 'commands'),
    ];

    for (const dir of rooDirs) {
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }
    }

    // 2. Copy rules templates (02-cli-usage.md, 03-skill-patterns.md)
    // Note: 01-skills-index.md is generated by init command, not copied
    const rulesFiles = ['02-cli-usage.md', '03-skill-patterns.md'];
    for (const file of rulesFiles) {
      const src = join(templates, 'rules', file);
      const dest = join(projectRoot, '.roo', 'rules', file);

      if (existsSync(src)) {
        copyFileSync(src, dest);
        filesInstalled.push(`.roo/rules/${file}`);
      } else {
        errors.push(`Template not found: rules/${file}`);
      }
    }

    // 3. Copy rules-roo-commander templates
    const modeRulesDir = join(templates, 'rules-roo-commander');
    if (existsSync(modeRulesDir)) {
      const modeRulesFiles = readdirSync(modeRulesDir);
      for (const file of modeRulesFiles) {
        if (file.endsWith('.md')) {
          const src = join(modeRulesDir, file);
          const dest = join(projectRoot, '.roo', 'rules-roo-commander', file);
          copyFileSync(src, dest);
          filesInstalled.push(`.roo/rules-roo-commander/${file}`);
        }
      }
    } else {
      errors.push('rules-roo-commander templates directory not found');
    }

    // 4. Copy slash commands
    const commandsDir = join(templates, 'commands');
    if (existsSync(commandsDir)) {
      const commandFiles = readdirSync(commandsDir);
      for (const file of commandFiles) {
        if (file.endsWith('.md')) {
          const src = join(commandsDir, file);
          const dest = join(projectRoot, '.roo', 'commands', file);
          copyFileSync(src, dest);
          filesInstalled.push(`.roo/commands/${file}`);
        }
      }
    } else {
      errors.push('commands templates directory not found');
    }

    // 5. Create or merge .roomodes file
    const roomodesResult = await createOrMergeRoomodes(projectRoot, templates);
    if (roomodesResult.success) {
      filesInstalled.push('.roomodes');
    } else {
      errors.push(roomodesResult.error || 'Failed to create/merge .roomodes');
    }

    spinner.succeed(chalk.green('✅ Roo Commander templates installed'));

    return {
      success: errors.length === 0,
      filesInstalled,
      errors,
    };
  } catch (error) {
    spinner.fail(chalk.red('Failed to install templates'));
    errors.push((error as Error).message);

    return {
      success: false,
      filesInstalled,
      errors,
    };
  }
}

/**
 * Create or merge .roomodes file
 *
 * If .roomodes exists, merge Roo Commander entry.
 * If doesn't exist, create new file with Roo Commander entry.
 *
 * @param projectRoot Project root directory
 * @param templatesDir Templates directory
 * @returns Result with success status
 */
async function createOrMergeRoomodes(
  projectRoot: string,
  templatesDir: string
): Promise<{ success: boolean; error?: string }> {
  const roomodesPath = join(projectRoot, '.roomodes');
  const templatePath = join(templatesDir, '.roomodes-entry.yaml');

  // Read template entry
  if (!existsSync(templatePath)) {
    return {
      success: false,
      error: '.roomodes-entry.yaml template not found',
    };
  }

  const templateContent = readFileSync(templatePath, 'utf-8');

  // Parse template to get Roo Commander entry
  // Template has comments, extract just the YAML entry
  const yamlStart = templateContent.indexOf('customModes:');
  if (yamlStart === -1) {
    return {
      success: false,
      error: 'Invalid .roomodes-entry.yaml template (missing customModes key)',
    };
  }

  const yamlContent = templateContent.substring(yamlStart);

  try {
    // Parse template (has customModes wrapper)
    const parsedTemplate = yaml.parse(yamlContent);
    if (!parsedTemplate?.customModes || !Array.isArray(parsedTemplate.customModes)) {
      return {
        success: false,
        error: 'Invalid .roomodes-entry.yaml template (customModes must be an array)',
      };
    }
    const rooCommanderMode = parsedTemplate.customModes[0];

    // Check if .roomodes exists
    if (existsSync(roomodesPath)) {
      // Merge with existing
      const existingContent = readFileSync(roomodesPath, 'utf-8');
      const existingData = yaml.parse(existingContent) || {};

      // Ensure customModes array exists
      if (!existingData.customModes) {
        existingData.customModes = [];
      }

      // Check if Roo Commander already exists
      const hasRooCommander = existingData.customModes.some(
        (mode: any) => mode.slug === 'roo-commander'
      );

      if (hasRooCommander) {
        // Replace existing entry
        existingData.customModes = existingData.customModes.filter(
          (mode: any) => mode.slug !== 'roo-commander'
        );
        existingData.customModes.push(rooCommanderMode);

        const newContent = yaml.stringify(existingData);
        writeFileSync(roomodesPath, newContent, 'utf-8');

        console.log(
          chalk.gray(`\n  Updated existing Roo Commander entry in .roomodes`)
        );
      } else {
        // Append to existing
        existingData.customModes.push(rooCommanderMode);

        const newContent = yaml.stringify(existingData);
        writeFileSync(roomodesPath, newContent, 'utf-8');

        console.log(chalk.gray(`\n  Added Roo Commander entry to .roomodes`));
      }
    } else {
      // Create new .roomodes file with customModes wrapper
      const newData = {
        customModes: [rooCommanderMode]
      };
      const newContent = yaml.stringify(newData);
      writeFileSync(roomodesPath, newContent, 'utf-8');

      console.log(chalk.gray(`\n  Created .roomodes with Roo Commander entry`));
    }

    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: `Failed to parse/merge .roomodes: ${(error as Error).message}`,
    };
  }
}

/**
 * Get templates directory path
 *
 * @returns Path to src/templates/ directory
 */
function getTemplatesDir(): string {
  // When installed globally, templates are in package directory
  // __dirname is dist/installer/, templates are in src/templates/
  // For now, assume running from source
  return join(__dirname, '..', '..', 'src', 'templates');
}

/**
 * Check if Roo Commander is already installed
 *
 * @param projectRoot Project root directory
 * @returns True if installed
 */
export function isInstalled(projectRoot: string): boolean {
  const rooCommanderDir = join(projectRoot, '.roo', 'rules-roo-commander');
  return existsSync(rooCommanderDir);
}
