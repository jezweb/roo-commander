Java Generics allow types (classes and interfaces) to be parameters when defining classes, interfaces, and methods. This enhances code reusability and provides compile-time type safety. [8, 29]

### Type Parameters and Type Arguments

*   **Type Parameter:** A placeholder for a type in a generic definition (e.g., `T` in `class Box<T>`). Type parameters are specified in angle brackets (`<>`) following the class or interface name. [20, 21]
*   **Type Argument:** An actual type (like `Integer` or `String`) supplied when invoking or instantiating a generic type (e.g., `Integer` in `Box<Integer>`). [20, 21]
*   **Naming Conventions:** By convention, type parameter names are single, uppercase letters (e.g., `E` for Element, `K` for Key, `V` for Value, `T` for Type, `N` for Number). [29]

### Generic Classes/Interfaces

A generic class or interface is declared with one or more type parameters. [20]

**Example: Generic Class**
```java
/**
 * Generic version of the Box class.
 * @param <T> the type of the value being boxed
 */
public class Box<T> {
    // T stands for "Type"
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```*(Source: Oracle Java Tutorials [20])*

To use this class, you provide a type argument:
```java
Box<Integer> integerBox = new Box<>(); // Using diamond operator for type inference
integerBox.set(10);
Integer someInteger = integerBox.get();
```
*(Source: Oracle Java Tutorials [20])*

Generic interfaces are defined similarly. [20, 29]

### Generic Methods

Methods can also be generic, introducing their own type parameters. These parameters are declared before the method's return type. [30, 36]

**Example: Generic Method**
```java
public class Util {
    // Generic static method
    public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }
}

// Assuming Pair<K, V> class exists
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.<Integer, String>compare(p1, p2); // Explicit type arguments
boolean sameInferred = Util.compare(p1, p2); // Type arguments inferred by compiler
```
*(Source: Based on Oracle Java Tutorials concepts)*

### Type Erasure

Generics are primarily a compile-time feature implemented through type erasure. The compiler replaces generic type information with actual types (or `Object`) and inserts necessary casts. [19, 24]

*   **Process:**
    1.  Replace all type parameters with their bounds (if bounded) or `Object` (if unbounded). [22, 24]
    2.  Insert type casts where needed to maintain type safety. [19, 24]
    3.  Generate bridge methods to preserve polymorphism in subclasses that override generic methods. [24]
*   **Result:** The generated bytecode contains only ordinary classes, interfaces, and methods, ensuring no runtime overhead for generics. [8, 24] Generic type information is generally not available at runtime, although some metadata is kept in the class file's "Signature" attribute for reflection purposes. [1, 3, 24]

**Example:**
*   `Node<T>` becomes `Node` with `T` replaced by `Object`. [22]
*   `Node<T extends Comparable<T>>` becomes `Node` with `T` replaced by `Comparable`. [22]

### Bounded Type Parameters (`extends`, `super`)

You can restrict the types that can be used as type arguments. [11, 12]

*   **Upper Bounds (`extends`):** Restricts the unknown type to a specific type or one of its subtypes. Uses the `extends` keyword (applies to both class extension and interface implementation). [11, 12]
    ```java
    // Restricts U to Number or its subclasses/implementors
    public <U extends Number> void inspect(U u) { /* ... */ }
    ```
    *(Source: Oracle Java Tutorials [12])*
    You can specify multiple bounds using `&` (e.g., `<T extends Number & Comparable>`). If a class is included, it must be listed first. [11, 36]

*   **Lower Bounds (`super`):** Used with wildcards (`?`), not directly with named type parameters for declaration. Restricts the unknown type to a specific type or one of its supertypes. [14, 17] The reason `super` isn't used for declaring named type parameters relates to complexities in type inference algorithms. [14]

### Wildcards (`?`, `? extends T`, `? super T`)

The wildcard (`?`) represents an unknown type. It's used to increase flexibility, especially with collections or generic classes. [8, 13]

*   **Upper Bounded Wildcards (`? extends Type`):** Represents an unknown subtype of `Type`. Useful when you only need to *read* items from a structure (producer). You can get objects of type `Type` (or its supertypes like `Object`), but you generally cannot add elements (except `null`) because the exact subtype is unknown. [10, 13, 26]
    ```java
    // Works for List<Integer>, List<Double>, etc.
    public static double sumOfList(List<? extends Number> list) {
        double sum = 0.0;
        for (Number n : list) { // Can read Number objects
            sum += n.doubleValue();
        }
        // list.add(new Integer(1)); // Compile-time error
        return sum;
    }
    ```
    *(Source: Oracle Java Tutorials [25], modified based on [13])*

*   **Lower Bounded Wildcards (`? super Type`):** Represents an unknown supertype of `Type`. Useful when you only need to *add* items of type `Type` (or its subtypes) to a structure (consumer). You can add `Type` objects or its subtypes, but reading elements only guarantees `Object`. [10, 17]
    ```java
    // Works for List<Integer>, List<Number>, List<Object>
    public static void addNumbers(List<? super Integer> list) {
        for (int i = 1; i <= 10; i++) {
            list.add(i); // Can add Integer objects
        }
        // Number n = list.get(0); // Compile-time error (returns Object)
    }
    ```
    *(Source: Oracle Java Tutorials [17])*

*   **Unbounded Wildcards (`?`):** Represents any type. Useful when the type doesn't matter (e.g., calling methods from `Object` like `size()` or `clear()`, or when methods don't depend on the type parameter). `List<?>` means a list holding objects of some unknown type. You cannot safely add elements (except `null`) to a `List<?>`. [10, 13]
    ```java
    public static void printList(List<?> list) {
        for (Object elem : list) { // Can read Object objects
            System.out.print(elem + " ");
        }
        System.out.println();
        // list.add("hello"); // Compile-time error
    }
    ```
    *(Source: Oracle Java Tutorials [13])*

*   **PECS Principle (Producer Extends, Consumer Super):** A guideline for using wildcards: Use `extends` when you only get values out (Producer), use `super` when you only put values in (Consumer). If you do both, don't use a wildcard. [10, 13]

### Raw Types

A raw type is the name of a generic class or interface used without any type arguments. [2, 18]
```java
Box rawBox = new Box(); // rawBox is a raw type of Box<T>
```
*(Source: Oracle Java Tutorials [18])*

*   **Behavior:** Raw types essentially behave like the class did before generics were introduced, bypassing generic type checks at compile time. This defers potential `ClassCastException` errors to runtime. [2, 18]
*   **Usage:** Primarily exist for backward compatibility with pre-Java 5 code. You should avoid using raw types in new code. [2, 18, 32] Using `List` is different from `List<Object>`. While both can hold any object, `List<Object>` is type-safe, whereas the raw type `List` is not. [2]

### Generic Type Inference

Type inference is the Java compiler's ability to determine the type arguments for a generic method call or constructor invocation based on the context (method arguments, assignment target). [8, 27, 37]

*   **Generic Methods:** Allows calling generic methods like ordinary methods without explicitly providing type arguments in angle brackets. [27, 29]
    ```java
    // Type <Integer, String> inferred from arguments p1, p2
    boolean sameInferred = Util.compare(p1, p2);
    ```
*   **Diamond Operator (`<>`):** Since Java 7, allows omitting type arguments in constructor calls if the compiler can infer them from the variable declaration. [20, 27]
    ```java
    List<String> list = new ArrayList<>(); // Compiler infers String
    ```
    *(Source: Oracle Java Tutorials [20])*

### Restrictions on Generics

Due to type erasure, there are several restrictions: [9]

1.  **Cannot Instantiate with Primitive Types:** Type arguments must be reference types (e.g., `Integer`, not `int`). Autoboxing helps here. [9]
2.  **Cannot Create Instances of Type Parameters:** You cannot do `new T()`. [9]
3.  **Cannot Declare Static Fields of Type Parameter Types:** Static variables are shared across all instances, but type parameters are instance-specific. [9]
4.  **Cannot Use `instanceof` or Casts with Parameterized Types:** `list instanceof ArrayList<Integer>` is illegal because the runtime doesn't know the `<Integer>` part. You can use `instanceof ArrayList<?>` or cast to the raw type `ArrayList` (with warnings). [9, 26]
5.  **Cannot Create Arrays of Parameterized Types:** `new List<String>[10]` is illegal due to type safety issues with array covariance. [6, 9]
6.  **Cannot Create, Catch, or Throw Generic Exception Classes:** Cannot extend `Throwable` with a type parameter. [9]
7.  **Cannot Overload Methods Where Signatures Erase to the Same Type:** Cannot have `void print(List<String> list)` and `void print(List<Integer> list)` in the same class, as both erase to `void print(List list)`. [9]

### Best Practices

*   **Use Generics for Type Safety:** Avoid raw types in new code. [23, 29]
*   **Use Bounded Types:** Restrict type parameters when necessary using `extends`. [16, 23]
*   **Prefer Generic Methods:** Use generic methods for flexibility when type parameters are needed locally. [23]
*   **Use Wildcards for API Flexibility:** Apply the PECS principle (`extends` for producers, `super` for consumers) for method parameters. [10, 16, 23]
*   **Avoid Wildcards in Return Types:** Can make APIs harder to use. [10, 23]
*   **Declare Collections Using Interface Types:** `List<String> list = new ArrayList<>();` rather than `ArrayList<String> list = new ArrayList<>();`. [16, 23]
*   **Leverage Type Inference:** Use the diamond operator (`<>`). [16, 23]
*   **Understand Type Erasure:** Be aware that generic type information is mostly unavailable at runtime. [23]
*   **Document Generic Type Parameters:** Use `@param <T>` in Javadoc. [34]

---
*Sources primarily based on The Java™ Tutorials (Oracle) [8, 9, 10, 12, 13, 17, 18, 20, 22, 24, 27, 28, 30] and supplemented by other sources as cited.*